/**
 * Stratis Node API
 * Access to the Stratis Node's api.
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.0.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "StratisCPPLightClient/model/TransactionOutputModel.h"

namespace stratis {
namespace api {
namespace model {

TransactionOutputModel::TransactionOutputModel() {
  m_Address = utility::conversions::to_string_t("");
  m_AddressIsSet = false;
  m_AmountIsSet = false;
  m_OpReturnData = utility::conversions::to_string_t("");
  m_OpReturnDataIsSet = false;
}

TransactionOutputModel::~TransactionOutputModel() {}

void TransactionOutputModel::validate() {
  // TODO: implement validation
}

web::json::value TransactionOutputModel::toJson() const {

  web::json::value val = web::json::value::object();

  if (m_AddressIsSet) {
    val[utility::conversions::to_string_t(U("address"))] =
        ModelBase::toJson(m_Address);
  }
  if (m_AmountIsSet) {
    val[utility::conversions::to_string_t(U("amount"))] =
        ModelBase::toJson(m_Amount);
  }
  if (m_OpReturnDataIsSet) {
    val[utility::conversions::to_string_t(U("opReturnData"))] =
        ModelBase::toJson(m_OpReturnData);
  }

  return val;
}

bool TransactionOutputModel::fromJson(const web::json::value &val) {
  bool ok = true;

  if (val.has_field(utility::conversions::to_string_t(U("address")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("address")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setAddress;
      ok &= ModelBase::fromJson(fieldValue, refVal_setAddress);
      setAddress(refVal_setAddress);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("amount")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("amount")));
    if (!fieldValue.is_null()) {
      std::shared_ptr<Money> refVal_setAmount;
      ok &= ModelBase::fromJson(fieldValue, refVal_setAmount);
      setAmount(refVal_setAmount);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("opReturnData")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("opReturnData")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setOpReturnData;
      ok &= ModelBase::fromJson(fieldValue, refVal_setOpReturnData);
      setOpReturnData(refVal_setOpReturnData);
    }
  }
  return ok;
}

void TransactionOutputModel::toMultipart(
    std::shared_ptr<MultipartFormData> multipart,
    const utility::string_t &prefix) const {
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }
  if (m_AddressIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("address")),
        m_Address));
  }
  if (m_AmountIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("amount")), m_Amount));
  }
  if (m_OpReturnDataIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("opReturnData")),
        m_OpReturnData));
  }
}

bool TransactionOutputModel::fromMultiPart(
    std::shared_ptr<MultipartFormData> multipart,
    const utility::string_t &prefix) {
  bool ok = true;
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }

  if (multipart->hasContent(utility::conversions::to_string_t(U("address")))) {
    utility::string_t refVal_setAddress;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("address"))),
        refVal_setAddress);
    setAddress(refVal_setAddress);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("amount")))) {
    std::shared_ptr<Money> refVal_setAmount;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("amount"))),
        refVal_setAmount);
    setAmount(refVal_setAmount);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("opReturnData")))) {
    utility::string_t refVal_setOpReturnData;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("opReturnData"))),
        refVal_setOpReturnData);
    setOpReturnData(refVal_setOpReturnData);
  }
  return ok;
}

utility::string_t TransactionOutputModel::getAddress() const {
  return m_Address;
}

void TransactionOutputModel::setAddress(const utility::string_t &value) {
  m_Address = value;
  m_AddressIsSet = true;
}

bool TransactionOutputModel::addressIsSet() const { return m_AddressIsSet; }

void TransactionOutputModel::unsetAddress() { m_AddressIsSet = false; }
std::shared_ptr<Money> TransactionOutputModel::getAmount() const {
  return m_Amount;
}

void TransactionOutputModel::setAmount(const std::shared_ptr<Money> &value) {
  m_Amount = value;
  m_AmountIsSet = true;
}

bool TransactionOutputModel::amountIsSet() const { return m_AmountIsSet; }

void TransactionOutputModel::unsetAmount() { m_AmountIsSet = false; }
utility::string_t TransactionOutputModel::getOpReturnData() const {
  return m_OpReturnData;
}

void TransactionOutputModel::setOpReturnData(const utility::string_t &value) {
  m_OpReturnData = value;
  m_OpReturnDataIsSet = true;
}

bool TransactionOutputModel::opReturnDataIsSet() const {
  return m_OpReturnDataIsSet;
}

void TransactionOutputModel::unsetOpReturnData() {
  m_OpReturnDataIsSet = false;
}
} // namespace model
} // namespace api
} // namespace stratis
