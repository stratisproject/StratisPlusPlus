/**
 * Stratis Node API
 * Access to the Stratis Node's api.
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.0.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "StratisCPPLightClient/model/NFTContractModel.h"

namespace stratis {
namespace api {
namespace model {

NFTContractModel::NFTContractModel() {
  m_Id = 0;
  m_IdIsSet = false;
  m_ContractAddress = utility::conversions::to_string_t("");
  m_ContractAddressIsSet = false;
  m_OwnedIDsByAddressIsSet = false;
  m_LastUpdatedBlock = 0;
  m_LastUpdatedBlockIsSet = false;
}

NFTContractModel::~NFTContractModel() {}

void NFTContractModel::validate() {
  // TODO: implement validation
}

web::json::value NFTContractModel::toJson() const {

  web::json::value val = web::json::value::object();

  if (m_IdIsSet) {
    val[utility::conversions::to_string_t(U("Id"))] = ModelBase::toJson(m_Id);
  }
  if (m_ContractAddressIsSet) {
    val[utility::conversions::to_string_t(U("ContractAddress"))] =
        ModelBase::toJson(m_ContractAddress);
  }
  if (m_OwnedIDsByAddressIsSet) {
    val[utility::conversions::to_string_t(U("OwnedIDsByAddress"))] =
        ModelBase::toJson(m_OwnedIDsByAddress);
  }
  if (m_LastUpdatedBlockIsSet) {
    val[utility::conversions::to_string_t(U("LastUpdatedBlock"))] =
        ModelBase::toJson(m_LastUpdatedBlock);
  }

  return val;
}

bool NFTContractModel::fromJson(const web::json::value &val) {
  bool ok = true;

  if (val.has_field(utility::conversions::to_string_t(U("Id")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("Id")));
    if (!fieldValue.is_null()) {
      int32_t refVal_setId;
      ok &= ModelBase::fromJson(fieldValue, refVal_setId);
      setId(refVal_setId);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("ContractAddress")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("ContractAddress")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setContractAddress;
      ok &= ModelBase::fromJson(fieldValue, refVal_setContractAddress);
      setContractAddress(refVal_setContractAddress);
    }
  }
  if (val.has_field(
          utility::conversions::to_string_t(U("OwnedIDsByAddress")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("OwnedIDsByAddress")));
    if (!fieldValue.is_null()) {
      std::map<utility::string_t, Set<int64_t>> refVal_setOwnedIDsByAddress;
      ok &= ModelBase::fromJson(fieldValue, refVal_setOwnedIDsByAddress);
      setOwnedIDsByAddress(refVal_setOwnedIDsByAddress);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("LastUpdatedBlock")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("LastUpdatedBlock")));
    if (!fieldValue.is_null()) {
      int32_t refVal_setLastUpdatedBlock;
      ok &= ModelBase::fromJson(fieldValue, refVal_setLastUpdatedBlock);
      setLastUpdatedBlock(refVal_setLastUpdatedBlock);
    }
  }
  return ok;
}

void NFTContractModel::toMultipart(std::shared_ptr<MultipartFormData> multipart,
                                   const utility::string_t &prefix) const {
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }
  if (m_IdIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("Id")), m_Id));
  }
  if (m_ContractAddressIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("ContractAddress")),
        m_ContractAddress));
  }
  if (m_OwnedIDsByAddressIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("OwnedIDsByAddress")),
        m_OwnedIDsByAddress));
  }
  if (m_LastUpdatedBlockIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("LastUpdatedBlock")),
        m_LastUpdatedBlock));
  }
}

bool NFTContractModel::fromMultiPart(
    std::shared_ptr<MultipartFormData> multipart,
    const utility::string_t &prefix) {
  bool ok = true;
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }

  if (multipart->hasContent(utility::conversions::to_string_t(U("Id")))) {
    int32_t refVal_setId;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("Id"))),
        refVal_setId);
    setId(refVal_setId);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("ContractAddress")))) {
    utility::string_t refVal_setContractAddress;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("ContractAddress"))),
        refVal_setContractAddress);
    setContractAddress(refVal_setContractAddress);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("OwnedIDsByAddress")))) {
    std::map<utility::string_t, Set<int64_t>> refVal_setOwnedIDsByAddress;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("OwnedIDsByAddress"))),
        refVal_setOwnedIDsByAddress);
    setOwnedIDsByAddress(refVal_setOwnedIDsByAddress);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("LastUpdatedBlock")))) {
    int32_t refVal_setLastUpdatedBlock;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("LastUpdatedBlock"))),
        refVal_setLastUpdatedBlock);
    setLastUpdatedBlock(refVal_setLastUpdatedBlock);
  }
  return ok;
}

int32_t NFTContractModel::getId() const { return m_Id; }

void NFTContractModel::setId(int32_t value) {
  m_Id = value;
  m_IdIsSet = true;
}

bool NFTContractModel::idIsSet() const { return m_IdIsSet; }

void NFTContractModel::unsetId() { m_IdIsSet = false; }
utility::string_t NFTContractModel::getContractAddress() const {
  return m_ContractAddress;
}

void NFTContractModel::setContractAddress(const utility::string_t &value) {
  m_ContractAddress = value;
  m_ContractAddressIsSet = true;
}

bool NFTContractModel::contractAddressIsSet() const {
  return m_ContractAddressIsSet;
}

void NFTContractModel::unsetContractAddress() {
  m_ContractAddressIsSet = false;
}
std::map<utility::string_t, Set<int64_t>> &
NFTContractModel::getOwnedIDsByAddress() {
  return m_OwnedIDsByAddress;
}

void NFTContractModel::setOwnedIDsByAddress(
    const std::map<utility::string_t, Set<int64_t>> &value) {
  m_OwnedIDsByAddress = value;
  m_OwnedIDsByAddressIsSet = true;
}

bool NFTContractModel::ownedIDsByAddressIsSet() const {
  return m_OwnedIDsByAddressIsSet;
}

void NFTContractModel::unsetOwnedIDsByAddress() {
  m_OwnedIDsByAddressIsSet = false;
}
int32_t NFTContractModel::getLastUpdatedBlock() const {
  return m_LastUpdatedBlock;
}

void NFTContractModel::setLastUpdatedBlock(int32_t value) {
  m_LastUpdatedBlock = value;
  m_LastUpdatedBlockIsSet = true;
}

bool NFTContractModel::lastUpdatedBlockIsSet() const {
  return m_LastUpdatedBlockIsSet;
}

void NFTContractModel::unsetLastUpdatedBlock() {
  m_LastUpdatedBlockIsSet = false;
}
} // namespace model
} // namespace api
} // namespace stratis
