/**
 * Stratis Node API
 * Access to the Stratis Node's api.
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.0.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "lightweightapi/model/BlockHeaderModel.h"

namespace stratis {
namespace api {
namespace model {

BlockHeaderModel::BlockHeaderModel()
{
    m_Version = 0;
    m_VersionIsSet = false;
    m_Merkleroot = utility::conversions::to_string_t("");
    m_MerklerootIsSet = false;
    m_Nonce = 0;
    m_NonceIsSet = false;
    m_Bits = utility::conversions::to_string_t("");
    m_BitsIsSet = false;
    m_Previousblockhash = utility::conversions::to_string_t("");
    m_PreviousblockhashIsSet = false;
    m_Time = 0;
    m_TimeIsSet = false;
}

BlockHeaderModel::~BlockHeaderModel() {}

void BlockHeaderModel::validate()
{
    // TODO: implement validation
}

web::json::value BlockHeaderModel::toJson() const
{
    web::json::value val = web::json::value::object();

    if (m_VersionIsSet) {
        val[utility::conversions::to_string_t(U("version"))] =
            ModelBase::toJson(m_Version);
    }
    if (m_MerklerootIsSet) {
        val[utility::conversions::to_string_t(U("merkleroot"))] =
            ModelBase::toJson(m_Merkleroot);
    }
    if (m_NonceIsSet) {
        val[utility::conversions::to_string_t(U("nonce"))] =
            ModelBase::toJson(m_Nonce);
    }
    if (m_BitsIsSet) {
        val[utility::conversions::to_string_t(U("bits"))] =
            ModelBase::toJson(m_Bits);
    }
    if (m_PreviousblockhashIsSet) {
        val[utility::conversions::to_string_t(U("previousblockhash"))] =
            ModelBase::toJson(m_Previousblockhash);
    }
    if (m_TimeIsSet) {
        val[utility::conversions::to_string_t(U("time"))] =
            ModelBase::toJson(m_Time);
    }

    return val;
}

bool BlockHeaderModel::fromJson(const web::json::value& val)
{
    bool ok = true;

    if (val.has_field(utility::conversions::to_string_t(U("version")))) {
        const web::json::value& fieldValue =
            val.at(utility::conversions::to_string_t(U("version")));
        if (!fieldValue.is_null()) {
            int32_t refVal_setVersion;
            ok &= ModelBase::fromJson(fieldValue, refVal_setVersion);
            setVersion(refVal_setVersion);
        }
    }
    if (val.has_field(utility::conversions::to_string_t(U("merkleroot")))) {
        const web::json::value& fieldValue =
            val.at(utility::conversions::to_string_t(U("merkleroot")));
        if (!fieldValue.is_null()) {
            utility::string_t refVal_setMerkleroot;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMerkleroot);
            setMerkleroot(refVal_setMerkleroot);
        }
    }
    if (val.has_field(utility::conversions::to_string_t(U("nonce")))) {
        const web::json::value& fieldValue =
            val.at(utility::conversions::to_string_t(U("nonce")));
        if (!fieldValue.is_null()) {
            int32_t refVal_setNonce;
            ok &= ModelBase::fromJson(fieldValue, refVal_setNonce);
            setNonce(refVal_setNonce);
        }
    }
    if (val.has_field(utility::conversions::to_string_t(U("bits")))) {
        const web::json::value& fieldValue =
            val.at(utility::conversions::to_string_t(U("bits")));
        if (!fieldValue.is_null()) {
            utility::string_t refVal_setBits;
            ok &= ModelBase::fromJson(fieldValue, refVal_setBits);
            setBits(refVal_setBits);
        }
    }
    if (val.has_field(
            utility::conversions::to_string_t(U("previousblockhash")))) {
        const web::json::value& fieldValue =
            val.at(utility::conversions::to_string_t(U("previousblockhash")));
        if (!fieldValue.is_null()) {
            utility::string_t refVal_setPreviousblockhash;
            ok &= ModelBase::fromJson(fieldValue, refVal_setPreviousblockhash);
            setPreviousblockhash(refVal_setPreviousblockhash);
        }
    }
    if (val.has_field(utility::conversions::to_string_t(U("time")))) {
        const web::json::value& fieldValue =
            val.at(utility::conversions::to_string_t(U("time")));
        if (!fieldValue.is_null()) {
            int32_t refVal_setTime;
            ok &= ModelBase::fromJson(fieldValue, refVal_setTime);
            setTime(refVal_setTime);
        }
    }
    return ok;
}

void BlockHeaderModel::toMultipart(std::shared_ptr<MultipartFormData> multipart,
                                   const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                     utility::conversions::to_string_t(U("."))) {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if (m_VersionIsSet) {
        multipart->add(ModelBase::toHttpContent(
            namePrefix + utility::conversions::to_string_t(U("version")),
            m_Version));
    }
    if (m_MerklerootIsSet) {
        multipart->add(ModelBase::toHttpContent(
            namePrefix + utility::conversions::to_string_t(U("merkleroot")),
            m_Merkleroot));
    }
    if (m_NonceIsSet) {
        multipart->add(ModelBase::toHttpContent(
            namePrefix + utility::conversions::to_string_t(U("nonce")), m_Nonce));
    }
    if (m_BitsIsSet) {
        multipart->add(ModelBase::toHttpContent(
            namePrefix + utility::conversions::to_string_t(U("bits")), m_Bits));
    }
    if (m_PreviousblockhashIsSet) {
        multipart->add(ModelBase::toHttpContent(
            namePrefix + utility::conversions::to_string_t(U("previousblockhash")),
            m_Previousblockhash));
    }
    if (m_TimeIsSet) {
        multipart->add(ModelBase::toHttpContent(
            namePrefix + utility::conversions::to_string_t(U("time")), m_Time));
    }
}

bool BlockHeaderModel::fromMultiPart(
    std::shared_ptr<MultipartFormData> multipart,
    const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                     utility::conversions::to_string_t(U("."))) {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if (multipart->hasContent(utility::conversions::to_string_t(U("version")))) {
        int32_t refVal_setVersion;
        ok &= ModelBase::fromHttpContent(
            multipart->getContent(utility::conversions::to_string_t(U("version"))),
            refVal_setVersion);
        setVersion(refVal_setVersion);
    }
    if (multipart->hasContent(
            utility::conversions::to_string_t(U("merkleroot")))) {
        utility::string_t refVal_setMerkleroot;
        ok &= ModelBase::fromHttpContent(
            multipart->getContent(
                utility::conversions::to_string_t(U("merkleroot"))),
            refVal_setMerkleroot);
        setMerkleroot(refVal_setMerkleroot);
    }
    if (multipart->hasContent(utility::conversions::to_string_t(U("nonce")))) {
        int32_t refVal_setNonce;
        ok &= ModelBase::fromHttpContent(
            multipart->getContent(utility::conversions::to_string_t(U("nonce"))),
            refVal_setNonce);
        setNonce(refVal_setNonce);
    }
    if (multipart->hasContent(utility::conversions::to_string_t(U("bits")))) {
        utility::string_t refVal_setBits;
        ok &= ModelBase::fromHttpContent(
            multipart->getContent(utility::conversions::to_string_t(U("bits"))),
            refVal_setBits);
        setBits(refVal_setBits);
    }
    if (multipart->hasContent(
            utility::conversions::to_string_t(U("previousblockhash")))) {
        utility::string_t refVal_setPreviousblockhash;
        ok &= ModelBase::fromHttpContent(
            multipart->getContent(
                utility::conversions::to_string_t(U("previousblockhash"))),
            refVal_setPreviousblockhash);
        setPreviousblockhash(refVal_setPreviousblockhash);
    }
    if (multipart->hasContent(utility::conversions::to_string_t(U("time")))) {
        int32_t refVal_setTime;
        ok &= ModelBase::fromHttpContent(
            multipart->getContent(utility::conversions::to_string_t(U("time"))),
            refVal_setTime);
        setTime(refVal_setTime);
    }
    return ok;
}

int32_t BlockHeaderModel::getVersion() const { return m_Version; }

void BlockHeaderModel::setVersion(int32_t value)
{
    m_Version = value;
    m_VersionIsSet = true;
}

bool BlockHeaderModel::versionIsSet() const { return m_VersionIsSet; }

void BlockHeaderModel::unsetVersion() { m_VersionIsSet = false; }
utility::string_t BlockHeaderModel::getMerkleroot() const
{
    return m_Merkleroot;
}

void BlockHeaderModel::setMerkleroot(const utility::string_t& value)
{
    m_Merkleroot = value;
    m_MerklerootIsSet = true;
}

bool BlockHeaderModel::merklerootIsSet() const { return m_MerklerootIsSet; }

void BlockHeaderModel::unsetMerkleroot() { m_MerklerootIsSet = false; }
int32_t BlockHeaderModel::getNonce() const { return m_Nonce; }

void BlockHeaderModel::setNonce(int32_t value)
{
    m_Nonce = value;
    m_NonceIsSet = true;
}

bool BlockHeaderModel::nonceIsSet() const { return m_NonceIsSet; }

void BlockHeaderModel::unsetNonce() { m_NonceIsSet = false; }
utility::string_t BlockHeaderModel::getBits() const { return m_Bits; }

void BlockHeaderModel::setBits(const utility::string_t& value)
{
    m_Bits = value;
    m_BitsIsSet = true;
}

bool BlockHeaderModel::bitsIsSet() const { return m_BitsIsSet; }

void BlockHeaderModel::unsetBits() { m_BitsIsSet = false; }
utility::string_t BlockHeaderModel::getPreviousblockhash() const
{
    return m_Previousblockhash;
}

void BlockHeaderModel::setPreviousblockhash(const utility::string_t& value)
{
    m_Previousblockhash = value;
    m_PreviousblockhashIsSet = true;
}

bool BlockHeaderModel::previousblockhashIsSet() const
{
    return m_PreviousblockhashIsSet;
}

void BlockHeaderModel::unsetPreviousblockhash()
{
    m_PreviousblockhashIsSet = false;
}
int32_t BlockHeaderModel::getTime() const { return m_Time; }

void BlockHeaderModel::setTime(int32_t value)
{
    m_Time = value;
    m_TimeIsSet = true;
}

bool BlockHeaderModel::timeIsSet() const { return m_TimeIsSet; }

void BlockHeaderModel::unsetTime() { m_TimeIsSet = false; }
} // namespace model
} // namespace api
} // namespace stratis
